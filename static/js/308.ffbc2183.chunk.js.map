{"version":3,"file":"static/js/308.ffbc2183.chunk.js","mappings":"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","sources":["../node_modules/lenis/src/maths.js","../node_modules/src/animate.ts","../node_modules/src/dimensions.ts","../node_modules/lenis/src/debounce.js","../node_modules/src/emitter.ts","../node_modules/src/virtual-scroll.ts","../node_modules/src/index.ts","../node_modules/locomotive-scroll/core/IO.ts","../node_modules/locomotive-scroll/utils/maths.ts","../node_modules/locomotive-scroll/core/ScrollElement.ts","../node_modules/locomotive-scroll/core/Core.ts","../node_modules/locomotive-scroll/core/RO.ts","../node_modules/locomotive-scroll/index.ts"],"sourcesContent":["// Clamp a value between a minimum and maximum value\r\nexport function clamp(min, input, max) {\r\n  return Math.max(min, Math.min(input, max))\r\n}\r\n\r\n// Truncate a floating-point number to a specified number of decimal places\r\nexport function truncate(value, decimals = 0) {\r\n  return parseFloat(value.toFixed(decimals))\r\n}\r\n\r\n// Linearly interpolate between two values using an amount (0 <= t <= 1)\r\nexport function lerp(x, y, t) {\r\n  return (1 - t) * x + t * y\r\n}\r\n\r\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\r\nexport function damp(x, y, lambda, dt) {\r\n  return lerp(x, y, 1 - Math.exp(-lambda * dt))\r\n}\r\n\r\n// Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\r\n// https://anguscroll.com/just/just-modulo\r\nexport function modulo(n, d) {\r\n  return ((n % d) + d) % d\r\n}\r\n","import { clamp, damp } from './maths'\r\n\r\n// Animate class to handle value animations with lerping or easing\r\nexport class Animate {\r\n  isRunning: boolean = false\r\n  value: number = 0\r\n  from: number = 0\r\n  to: number = 0\r\n  lerp?: number\r\n  duration?: number = 0\r\n  easing?: Function\r\n  currentTime: number = 0\r\n  onUpdate?: Function\r\n\r\n  // Advance the animation by the given delta time\r\n  advance(deltaTime: number) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.duration && this.easing) {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    } else if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      // If no easing or lerp, just jump to the end value\r\n      this.value = this.to\r\n      completed = true\r\n    }\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, completed)\r\n  }\r\n\r\n  // Stop the animation\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  // Set up the animation from a starting value to an ending value\r\n  // with optional parameters for lerping, duration, easing, and onUpdate callback\r\n  fromTo(\r\n    from: number,\r\n    to: number,\r\n    {\r\n      lerp,\r\n      duration,\r\n      easing,\r\n      onStart,\r\n      onUpdate,\r\n    }: {\r\n      lerp?: number\r\n      duration?: number\r\n      easing?: Function\r\n      onStart?: Function\r\n      onUpdate?: Function\r\n    }\r\n  ) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    onStart?.()\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n","import { debounce } from './debounce'\r\n\r\ntype DimensionsOptions = {\r\n  wrapper: Window | HTMLElement\r\n  content: HTMLElement\r\n  autoResize?: boolean\r\n  debounce?: number\r\n}\r\n\r\nexport class Dimensions {\r\n  wrapper: Window | HTMLElement\r\n  content: HTMLElement\r\n  width: number = 0\r\n  height: number = 0\r\n  scrollWidth: number = 0\r\n  scrollHeight: number = 0\r\n  debouncedResize?: Function\r\n  wrapperResizeObserver?: ResizeObserver\r\n  contentResizeObserver?: ResizeObserver\r\n\r\n  // @ts-ignore\r\n  constructor({\r\n    wrapper,\r\n    content,\r\n    autoResize = true,\r\n    debounce: debounceValue = 250,\r\n  }: DimensionsOptions = {}) {\r\n    this.wrapper = wrapper\r\n    this.content = content\r\n\r\n    if (autoResize) {\r\n      this.debouncedResize = debounce(this.resize, debounceValue)\r\n\r\n      if (this.wrapper === window) {\r\n        window.addEventListener(\r\n          'resize',\r\n          this.debouncedResize as EventListener,\r\n          false\r\n        )\r\n      } else {\r\n        this.wrapperResizeObserver = new ResizeObserver(\r\n          this.debouncedResize as ResizeObserverCallback\r\n        )\r\n        this.wrapperResizeObserver.observe(this.wrapper as HTMLElement)\r\n      }\r\n\r\n      this.contentResizeObserver = new ResizeObserver(\r\n        this.debouncedResize as ResizeObserverCallback\r\n      )\r\n      this.contentResizeObserver.observe(this.content)\r\n    }\r\n\r\n    this.resize()\r\n  }\r\n\r\n  destroy() {\r\n    this.wrapperResizeObserver?.disconnect()\r\n    this.contentResizeObserver?.disconnect()\r\n    window.removeEventListener(\r\n      'resize',\r\n      this.debouncedResize as EventListener,\r\n      false\r\n    )\r\n  }\r\n\r\n  resize = () => {\r\n    this.onWrapperResize()\r\n    this.onContentResize()\r\n  }\r\n\r\n  onWrapperResize = () => {\r\n    if (this.wrapper === window) {\r\n      this.width = window.innerWidth\r\n      this.height = window.innerHeight\r\n    } else if (this.wrapper instanceof HTMLElement) {\r\n      this.width = this.wrapper.clientWidth\r\n      this.height = this.wrapper.clientHeight\r\n    }\r\n  }\r\n\r\n  onContentResize = () => {\r\n    if (this.wrapper === window) {\r\n      this.scrollHeight = this.content.scrollHeight\r\n      this.scrollWidth = this.content.scrollWidth\r\n    } else if (this.wrapper instanceof HTMLElement) {\r\n      this.scrollHeight = this.wrapper.scrollHeight\r\n      this.scrollWidth = this.wrapper.scrollWidth\r\n    }\r\n  }\r\n\r\n  get limit(): {\r\n    x: number\r\n    y: number\r\n  } {\r\n    return {\r\n      x: this.scrollWidth - this.width,\r\n      y: this.scrollHeight - this.height,\r\n    }\r\n  }\r\n}\r\n","export function debounce(callback, delay) {\r\n  let timer\r\n  return function () {\r\n    let args = arguments\r\n    let context = this\r\n    clearTimeout(timer)\r\n    timer = setTimeout(function () {\r\n      callback.apply(context, args)\r\n    }, delay)\r\n  }\r\n}\r\n","export class Emitter {\r\n  events: Record<string, Function[]>\r\n\r\n  constructor() {\r\n    this.events = {}\r\n  }\r\n\r\n  emit(event: string, ...args: any[]) {\r\n    let callbacks = this.events[event] || []\r\n    for (let i = 0, length = callbacks.length; i < length; i++) {\r\n      callbacks[i](...args)\r\n    }\r\n  }\r\n\r\n  on(event: string, callback: Function) {\r\n    // Add the callback to the event's callback list, or create a new list with the callback\r\n    this.events[event]?.push(callback) || (this.events[event] = [callback])\r\n\r\n    // Return an unsubscribe function\r\n    return () => {\r\n      this.events[event] = this.events[event]?.filter((i) => callback !== i)\r\n    }\r\n  }\r\n\r\n  off(event: string, callback: Function) {\r\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\r\n  }\r\n\r\n  destroy() {\r\n    this.events = {}\r\n  }\r\n}\r\n","import { Emitter } from './emitter'\r\n\r\nconst LINE_HEIGHT = 100 / 6\r\n\r\nexport class VirtualScroll {\r\n  element: HTMLElement | Window\r\n  wheelMultiplier: number\r\n  touchMultiplier: number\r\n  touchStart: {\r\n    x: number | null\r\n    y: number | null\r\n  }\r\n  emitter: Emitter\r\n  lastDelta: {\r\n    x: number\r\n    y: number\r\n  } = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  windowWidth: number = 0\r\n  windowHeight: number = 0\r\n\r\n  constructor(\r\n    element: HTMLElement | Window,\r\n    { wheelMultiplier = 1, touchMultiplier = 1 }\r\n  ) {\r\n    this.element = element\r\n    this.wheelMultiplier = wheelMultiplier\r\n    this.touchMultiplier = touchMultiplier\r\n\r\n    this.touchStart = {\r\n      x: null,\r\n      y: null,\r\n    }\r\n\r\n    this.emitter = new Emitter()\r\n    window.addEventListener('resize', this.onWindowResize, false)\r\n    this.onWindowResize()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel as EventListener, {\r\n      passive: false,\r\n    })\r\n    this.element.addEventListener(\r\n      'touchstart',\r\n      this.onTouchStart as EventListener,\r\n      {\r\n        passive: false,\r\n      }\r\n    )\r\n    this.element.addEventListener(\r\n      'touchmove',\r\n      this.onTouchMove as EventListener,\r\n      {\r\n        passive: false,\r\n      }\r\n    )\r\n    this.element.addEventListener(\r\n      'touchend',\r\n      this.onTouchEnd as EventListener,\r\n      {\r\n        passive: false,\r\n      }\r\n    )\r\n  }\r\n\r\n  // Add an event listener for the given event and callback\r\n  on(event: string, callback: Function) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  // Remove all event listeners and clean up\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    window.removeEventListener('resize', this.onWindowResize, false)\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel as EventListener)\r\n    this.element.removeEventListener(\r\n      'touchstart',\r\n      this.onTouchStart as EventListener\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchmove',\r\n      this.onTouchMove as EventListener\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchend',\r\n      this.onTouchEnd as EventListener\r\n    )\r\n  }\r\n\r\n  // Event handler for 'touchstart' event\r\n  onTouchStart = (event: TouchEvent) => {\r\n    // @ts-expect-error\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX: 0,\r\n      deltaY: 0,\r\n      event,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'touchmove' event\r\n  onTouchMove = (event: TouchEvent) => {\r\n    // @ts-expect-error\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - (this.touchStart?.x ?? 0)) * this.touchMultiplier\r\n    const deltaY = -(clientY - (this.touchStart?.y ?? 0)) * this.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event: TouchEvent) => {\r\n    this.emitter.emit('scroll', {\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  // Event handler for 'wheel' event\r\n  onWheel = (event: WheelEvent) => {\r\n    let { deltaX, deltaY, deltaMode } = event\r\n\r\n    const multiplierX =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.windowWidth : 1\r\n    const multiplierY =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.windowHeight : 1\r\n\r\n    deltaX *= multiplierX\r\n    deltaY *= multiplierY\r\n\r\n    deltaX *= this.wheelMultiplier\r\n    deltaY *= this.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\r\n  }\r\n\r\n  onWindowResize = () => {\r\n    this.windowWidth = window.innerWidth\r\n    this.windowHeight = window.innerHeight\r\n  }\r\n}\r\n","import { version } from '../../../package.json'\r\nimport { Animate } from './animate'\r\nimport { Dimensions } from './dimensions'\r\nimport { Emitter } from './emitter'\r\nimport { clamp, modulo } from './maths'\r\nimport { VirtualScroll } from './virtual-scroll'\r\n\r\n// Technical explanation\r\n// - listen to 'wheel' events\r\n// - prevent 'wheel' event to prevent scroll\r\n// - normalize wheel delta\r\n// - add delta to targetScroll\r\n// - animate scroll to targetScroll (smooth context)\r\n// - if animation is not running, listen to 'scroll' events (native context)\r\n\r\ntype Overwrite<T, R> = Omit<T, keyof R> & R\r\n\r\ntype EasingFunction = (t: number) => number\r\ntype Orientation = 'vertical' | 'horizontal'\r\ntype GestureOrientation = 'vertical' | 'horizontal' | 'both'\r\ntype Scrolling = boolean | 'native' | 'smooth'\r\n\r\ntype onVirtualScrollOptions = {\r\n  deltaX: number\r\n  deltaY: number\r\n  event: WheelEvent | TouchEvent\r\n}\r\n\r\nexport type LenisOptions = Partial<{\r\n  wrapper: Window | HTMLElement\r\n  content: HTMLElement\r\n  wheelEventsTarget: Window | HTMLElement\r\n  eventsTarget: Window | HTMLElement\r\n  smoothWheel: boolean\r\n  syncTouch: boolean\r\n  syncTouchLerp: number\r\n  touchInertiaMultiplier: number\r\n  duration: number\r\n  easing: EasingFunction\r\n  lerp: number\r\n  infinite: boolean\r\n  orientation: Orientation\r\n  gestureOrientation: GestureOrientation\r\n  touchMultiplier: number\r\n  wheelMultiplier: number\r\n  autoResize: boolean\r\n  prevent: (node: Element) => boolean\r\n  virtualScroll: (data: onVirtualScrollOptions) => boolean\r\n  __experimental__naiveDimensions: boolean\r\n}>\r\n\r\nexport default class Lenis {\r\n  // __isSmooth: boolean = false // true if scroll should be animated\r\n  __isScrolling: Scrolling = false // true when scroll is animating\r\n  __isStopped: boolean = false // true if user should not be able to scroll - enable/disable programmatically\r\n  __isLocked: boolean = false // same as isStopped but enabled/disabled when scroll reaches target\r\n  __preventNextNativeScrollEvent?: boolean\r\n  __resetVelocityTimeout?: number\r\n\r\n  isTouching?: boolean\r\n  time: number\r\n  userData: Object = {}\r\n  lastVelocity: number = 0\r\n  velocity: number = 0\r\n  direction: 1 | -1 | 0 = 0\r\n  options: Overwrite<\r\n    LenisOptions,\r\n    {\r\n      wrapper: NonNullable<LenisOptions['wrapper']>\r\n    }\r\n  >\r\n  targetScroll: number\r\n  animatedScroll: number\r\n  animate: Animate\r\n  emitter: Emitter\r\n  dimensions: Dimensions\r\n  virtualScroll: VirtualScroll\r\n\r\n  constructor({\r\n    wrapper = window,\r\n    content = document.documentElement,\r\n    wheelEventsTarget = wrapper, // deprecated\r\n    eventsTarget = wheelEventsTarget,\r\n    smoothWheel = true,\r\n    syncTouch = false,\r\n    syncTouchLerp = 0.075,\r\n    touchInertiaMultiplier = 35,\r\n    duration, // in seconds\r\n    easing = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n    lerp = 0.1,\r\n    infinite = false,\r\n    orientation = 'vertical', // vertical, horizontal\r\n    gestureOrientation = 'vertical', // vertical, horizontal, both\r\n    touchMultiplier = 1,\r\n    wheelMultiplier = 1,\r\n    autoResize = true,\r\n    prevent,\r\n    virtualScroll,\r\n    __experimental__naiveDimensions = false,\r\n  }: LenisOptions = {}) {\r\n    // @ts-expect-error\r\n    window.lenisVersion = version\r\n\r\n    // if wrapper is html or body, fallback to window\r\n    if (\r\n      !wrapper ||\r\n      wrapper === document.documentElement ||\r\n      wrapper === document.body\r\n    ) {\r\n      wrapper = window\r\n    }\r\n\r\n    this.options = {\r\n      wrapper,\r\n      content,\r\n      wheelEventsTarget,\r\n      eventsTarget,\r\n      smoothWheel,\r\n      syncTouch,\r\n      syncTouchLerp,\r\n      touchInertiaMultiplier,\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      infinite,\r\n      gestureOrientation,\r\n      orientation,\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n      autoResize,\r\n      prevent,\r\n      virtualScroll,\r\n      __experimental__naiveDimensions,\r\n    } as LenisOptions\r\n\r\n    this.animate = new Animate()\r\n    this.emitter = new Emitter()\r\n    this.dimensions = new Dimensions({ wrapper, content, autoResize })\r\n    // this.toggleClassName('lenis', true)\r\n    this.updateClassName()\r\n\r\n    this.userData = {}\r\n    this.time = 0\r\n    this.velocity = this.lastVelocity = 0\r\n    this.isLocked = false\r\n    this.isStopped = false\r\n    // this.hasScrolled = false\r\n    // this.isSmooth = syncTouch || smoothWheel\r\n    // this.isSmooth = false\r\n    this.isScrolling = false\r\n    this.targetScroll = this.animatedScroll = this.actualScroll\r\n\r\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, false)\r\n\r\n    this.options.wrapper.addEventListener(\r\n      'pointerdown',\r\n      this.onPointerDown as EventListener,\r\n      false\r\n    )\r\n\r\n    this.virtualScroll = new VirtualScroll(eventsTarget, {\r\n      touchMultiplier,\r\n      wheelMultiplier,\r\n    })\r\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\r\n  }\r\n\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    this.options.wrapper.removeEventListener(\r\n      'scroll',\r\n      this.onNativeScroll,\r\n      false\r\n    )\r\n    this.options.wrapper.removeEventListener(\r\n      'pointerdown',\r\n      this.onPointerDown as EventListener,\r\n      false\r\n    )\r\n\r\n    this.virtualScroll.destroy()\r\n    this.dimensions.destroy()\r\n\r\n    this.cleanUpClassName()\r\n\r\n    // this.rootElement.className = ''\r\n\r\n    // this.toggleClassName('lenis', false)\r\n    // this.toggleClassName('lenis-smooth', false)\r\n    // this.toggleClassName('lenis-scrolling', false)\r\n    // this.toggleClassName('lenis-stopped', false)\r\n    // this.toggleClassName('lenis-locked', false)\r\n  }\r\n\r\n  on(event: string, callback: Function) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  off(event: string, callback: Function) {\r\n    return this.emitter.off(event, callback)\r\n  }\r\n\r\n  private setScroll(scroll: number) {\r\n    // apply scroll value immediately\r\n    if (this.isHorizontal) {\r\n      this.rootElement.scrollLeft = scroll\r\n    } else {\r\n      this.rootElement.scrollTop = scroll\r\n    }\r\n  }\r\n\r\n  private onPointerDown = (event: PointerEvent | MouseEvent) => {\r\n    if (event.button === 1) {\r\n      this.reset()\r\n    }\r\n  }\r\n\r\n  private onVirtualScroll = (data: onVirtualScrollOptions) => {\r\n    if (\r\n      typeof this.options.virtualScroll === 'function' &&\r\n      this.options.virtualScroll(data) === false\r\n    )\r\n      return\r\n\r\n    const { deltaX, deltaY, event } = data\r\n\r\n    this.emitter.emit('virtual-scroll', { deltaX, deltaY, event })\r\n\r\n    // keep zoom feature\r\n    if (event.ctrlKey) return\r\n\r\n    const isTouch = event.type.includes('touch')\r\n    const isWheel = event.type.includes('wheel')\r\n\r\n    this.isTouching = event.type === 'touchstart' || event.type === 'touchmove'\r\n    // if (event.type === 'touchend') {\r\n    //   console.log('touchend', this.scroll)\r\n    //   // this.lastVelocity = this.velocity\r\n    //   // this.velocity = 0\r\n    //   // this.isScrolling = false\r\n    //   this.emit({ type: 'touchend' })\r\n    //   // alert('touchend')\r\n    //   return\r\n    // }\r\n\r\n    const isTapToStop =\r\n      this.options.syncTouch &&\r\n      isTouch &&\r\n      event.type === 'touchstart' &&\r\n      !this.isStopped &&\r\n      !this.isLocked\r\n\r\n    if (isTapToStop) {\r\n      this.reset()\r\n      return\r\n    }\r\n\r\n    const isClick = deltaX === 0 && deltaY === 0 // click event\r\n\r\n    // const isPullToRefresh =\r\n    //   this.options.gestureOrientation === 'vertical' &&\r\n    //   this.scroll === 0 &&\r\n    //   !this.options.infinite &&\r\n    //   deltaY <= 5 // touch pull to refresh, not reliable yet\r\n\r\n    const isUnknownGesture =\r\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) ||\r\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0)\r\n\r\n    if (isClick || isUnknownGesture) {\r\n      // console.log('prevent')\r\n      return\r\n    }\r\n\r\n    // catch if scrolling on nested scroll elements\r\n    let composedPath = event.composedPath()\r\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\r\n\r\n    const prevent = this.options.prevent\r\n\r\n    if (\r\n      !!composedPath.find(\r\n        (node) =>\r\n          node instanceof Element &&\r\n          ((typeof prevent === 'function' && prevent?.(node)) ||\r\n            node.hasAttribute?.('data-lenis-prevent') ||\r\n            (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\r\n            (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\r\n            (node.classList?.contains('lenis') &&\r\n              !node.classList?.contains('lenis-stopped'))) // nested lenis instance\r\n      )\r\n    )\r\n      return\r\n\r\n    if (this.isStopped || this.isLocked) {\r\n      event.preventDefault() // this will stop forwarding the event to the parent, this is problematic\r\n      return\r\n    }\r\n\r\n    const isSmooth =\r\n      (this.options.syncTouch && isTouch) ||\r\n      (this.options.smoothWheel && isWheel)\r\n\r\n    if (!isSmooth) {\r\n      this.isScrolling = 'native'\r\n      this.animate.stop()\r\n      return\r\n    }\r\n\r\n    event.preventDefault()\r\n\r\n    let delta = deltaY\r\n    if (this.options.gestureOrientation === 'both') {\r\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\r\n    } else if (this.options.gestureOrientation === 'horizontal') {\r\n      delta = deltaX\r\n    }\r\n\r\n    const syncTouch = isTouch && this.options.syncTouch\r\n    const isTouchEnd = isTouch && event.type === 'touchend'\r\n\r\n    const hasTouchInertia = isTouchEnd && Math.abs(delta) > 5\r\n\r\n    if (hasTouchInertia) {\r\n      delta = this.velocity * this.options.touchInertiaMultiplier\r\n    }\r\n\r\n    this.scrollTo(this.targetScroll + delta, {\r\n      programmatic: false,\r\n      ...(syncTouch\r\n        ? {\r\n            lerp: hasTouchInertia ? this.options.syncTouchLerp : 1,\r\n          }\r\n        : {\r\n            lerp: this.options.lerp,\r\n            duration: this.options.duration,\r\n            easing: this.options.easing,\r\n          }),\r\n    })\r\n  }\r\n\r\n  resize() {\r\n    this.dimensions.resize()\r\n  }\r\n\r\n  private emit() {\r\n    this.emitter.emit('scroll', this)\r\n  }\r\n\r\n  private onNativeScroll = () => {\r\n    clearTimeout(this.__resetVelocityTimeout)\r\n    delete this.__resetVelocityTimeout\r\n\r\n    if (this.__preventNextNativeScrollEvent) {\r\n      delete this.__preventNextNativeScrollEvent\r\n      return\r\n    }\r\n\r\n    if (this.isScrolling === false || this.isScrolling === 'native') {\r\n      const lastScroll = this.animatedScroll\r\n      this.animatedScroll = this.targetScroll = this.actualScroll\r\n      this.lastVelocity = this.velocity\r\n      this.velocity = this.animatedScroll - lastScroll\r\n      this.direction = Math.sign(\r\n        this.animatedScroll - lastScroll\r\n      ) as Lenis['direction']\r\n      // this.isSmooth = false\r\n      this.isScrolling = 'native'\r\n      this.emit()\r\n\r\n      if (this.velocity !== 0) {\r\n        this.__resetVelocityTimeout = setTimeout(() => {\r\n          this.lastVelocity = this.velocity\r\n          this.velocity = 0\r\n          this.isScrolling = false\r\n          this.emit()\r\n        }, 400)\r\n      }\r\n\r\n      // this.hasScrolled = true\r\n      // }, 50)\r\n    }\r\n  }\r\n\r\n  private reset() {\r\n    this.isLocked = false\r\n    this.isScrolling = false\r\n    this.animatedScroll = this.targetScroll = this.actualScroll\r\n    this.lastVelocity = this.velocity = 0\r\n    this.animate.stop()\r\n  }\r\n\r\n  start() {\r\n    if (!this.isStopped) return\r\n    this.isStopped = false\r\n\r\n    this.reset()\r\n  }\r\n\r\n  stop() {\r\n    if (this.isStopped) return\r\n    this.isStopped = true\r\n    this.animate.stop()\r\n\r\n    this.reset()\r\n  }\r\n\r\n  raf(time: number) {\r\n    const deltaTime = time - (this.time || time)\r\n    this.time = time\r\n\r\n    this.animate.advance(deltaTime * 0.001)\r\n  }\r\n\r\n  scrollTo(\r\n    target: number | string | HTMLElement,\r\n    {\r\n      offset = 0,\r\n      immediate = false,\r\n      lock = false,\r\n      duration = this.options.duration,\r\n      easing = this.options.easing,\r\n      lerp = this.options.lerp,\r\n      onStart,\r\n      onComplete,\r\n      force = false, // scroll even if stopped\r\n      programmatic = true, // called from outside of the class\r\n      userData = {},\r\n    }: {\r\n      offset?: number\r\n      immediate?: boolean\r\n      lock?: boolean\r\n      duration?: number\r\n      easing?: EasingFunction\r\n      lerp?: number\r\n      onStart?: (lenis: Lenis) => void\r\n      onComplete?: (lenis: Lenis) => void\r\n      force?: boolean\r\n      programmatic?: boolean\r\n      userData?: object\r\n    } = {}\r\n  ) {\r\n    if ((this.isStopped || this.isLocked) && !force) return\r\n\r\n    // keywords\r\n    if (\r\n      typeof target === 'string' &&\r\n      ['top', 'left', 'start'].includes(target)\r\n    ) {\r\n      target = 0\r\n    } else if (\r\n      typeof target === 'string' &&\r\n      ['bottom', 'right', 'end'].includes(target)\r\n    ) {\r\n      target = this.limit\r\n    } else {\r\n      let node\r\n\r\n      if (typeof target === 'string') {\r\n        // CSS selector\r\n        node = document.querySelector(target)\r\n      } else if (target instanceof HTMLElement && target?.nodeType) {\r\n        // Node element\r\n        node = target\r\n      }\r\n\r\n      if (node) {\r\n        if (this.options.wrapper !== window) {\r\n          // nested scroll offset correction\r\n          const wrapperRect = this.rootElement.getBoundingClientRect()\r\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\r\n        }\r\n\r\n        const rect = node.getBoundingClientRect()\r\n\r\n        target =\r\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\r\n      }\r\n    }\r\n\r\n    if (typeof target !== 'number') return\r\n\r\n    target += offset\r\n    target = Math.round(target)\r\n\r\n    if (this.options.infinite) {\r\n      if (programmatic) {\r\n        this.targetScroll = this.animatedScroll = this.scroll\r\n      }\r\n    } else {\r\n      target = clamp(0, target, this.limit)\r\n    }\r\n\r\n    if (target === this.targetScroll) return\r\n\r\n    this.userData = userData\r\n\r\n    if (immediate) {\r\n      this.animatedScroll = this.targetScroll = target\r\n      this.setScroll(this.scroll)\r\n      this.reset()\r\n      this.preventNextNativeScrollEvent()\r\n      this.emit()\r\n      onComplete?.(this)\r\n      this.userData = {}\r\n      return\r\n    }\r\n\r\n    if (!programmatic) {\r\n      this.targetScroll = target\r\n    }\r\n\r\n    this.animate.fromTo(this.animatedScroll, target, {\r\n      duration,\r\n      easing,\r\n      lerp,\r\n      onStart: () => {\r\n        // started\r\n        if (lock) this.isLocked = true\r\n        this.isScrolling = 'smooth'\r\n        onStart?.(this)\r\n      },\r\n      onUpdate: (value: number, completed: boolean) => {\r\n        this.isScrolling = 'smooth'\r\n\r\n        // updated\r\n        this.lastVelocity = this.velocity\r\n        this.velocity = value - this.animatedScroll\r\n        this.direction = Math.sign(this.velocity) as Lenis['direction']\r\n\r\n        this.animatedScroll = value\r\n        this.setScroll(this.scroll)\r\n\r\n        if (programmatic) {\r\n          // wheel during programmatic should stop it\r\n          this.targetScroll = value\r\n        }\r\n\r\n        if (!completed) this.emit()\r\n\r\n        if (completed) {\r\n          this.reset()\r\n          this.emit()\r\n          onComplete?.(this)\r\n          this.userData = {}\r\n\r\n          // avoid emitting event twice\r\n          this.preventNextNativeScrollEvent()\r\n        }\r\n      },\r\n    })\r\n  }\r\n\r\n  private preventNextNativeScrollEvent() {\r\n    this.__preventNextNativeScrollEvent = true\r\n\r\n    requestAnimationFrame(() => {\r\n      delete this.__preventNextNativeScrollEvent\r\n    })\r\n  }\r\n\r\n  get rootElement() {\r\n    return (\r\n      this.options.wrapper === window\r\n        ? document.documentElement\r\n        : this.options.wrapper\r\n    ) as HTMLElement\r\n  }\r\n\r\n  get limit() {\r\n    if (this.options.__experimental__naiveDimensions) {\r\n      if (this.isHorizontal) {\r\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth\r\n      } else {\r\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight\r\n      }\r\n    } else {\r\n      return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\r\n    }\r\n  }\r\n\r\n  get isHorizontal() {\r\n    return this.options.orientation === 'horizontal'\r\n  }\r\n\r\n  get actualScroll(): number {\r\n    // value browser takes into account\r\n    return this.isHorizontal\r\n      ? this.rootElement.scrollLeft\r\n      : this.rootElement.scrollTop\r\n  }\r\n\r\n  get scroll(): number {\r\n    return this.options.infinite\r\n      ? modulo(this.animatedScroll, this.limit)\r\n      : this.animatedScroll\r\n  }\r\n\r\n  get progress(): number {\r\n    // avoid progress to be NaN\r\n    return this.limit === 0 ? 1 : this.scroll / this.limit\r\n  }\r\n\r\n  // get isSmooth() {\r\n  //   return this.__isSmooth\r\n  // }\r\n\r\n  // private set isSmooth(value: boolean) {\r\n  //   if (this.__isSmooth !== value) {\r\n  //     this.__isSmooth = value\r\n  //     this.updateClassName()\r\n  //   }\r\n  // }\r\n\r\n  get isScrolling() {\r\n    return this.__isScrolling\r\n  }\r\n\r\n  private set isScrolling(value: Scrolling) {\r\n    if (this.__isScrolling !== value) {\r\n      this.__isScrolling = value\r\n      this.updateClassName()\r\n    }\r\n  }\r\n\r\n  get isStopped() {\r\n    return this.__isStopped\r\n  }\r\n\r\n  private set isStopped(value: boolean) {\r\n    if (this.__isStopped !== value) {\r\n      this.__isStopped = value\r\n      this.updateClassName()\r\n    }\r\n  }\r\n\r\n  get isLocked() {\r\n    return this.__isLocked\r\n  }\r\n\r\n  private set isLocked(value: boolean) {\r\n    if (this.__isLocked !== value) {\r\n      this.__isLocked = value\r\n      this.updateClassName()\r\n    }\r\n  }\r\n\r\n  get isSmooth() {\r\n    return this.isScrolling === 'smooth'\r\n  }\r\n\r\n  get className() {\r\n    let className = 'lenis'\r\n    if (this.isStopped) className += ' lenis-stopped'\r\n    if (this.isLocked) className += ' lenis-locked'\r\n    if (this.isScrolling) className += ' lenis-scrolling'\r\n    if (this.isScrolling === 'smooth') className += ' lenis-smooth'\r\n    // if (this.isScrolling === 'native') className += ' lenis-native'\r\n    // if (this.isSmooth) className += ' lenis-smooth'\r\n    return className\r\n  }\r\n\r\n  private updateClassName() {\r\n    this.cleanUpClassName()\r\n\r\n    this.rootElement.className =\r\n      `${this.rootElement.className} ${this.className}`.trim()\r\n  }\r\n\r\n  private cleanUpClassName() {\r\n    this.rootElement.className = this.rootElement.className\r\n      .replace(/lenis(-\\w+)?/g, '')\r\n      .trim()\r\n  }\r\n}\r\n","/**\n * Intersection Observer\n *\n * Detecting visibility of an element in the viewport.\n *\n * Features functions to:\n *\n * - Trigger inview/outOfView callbacks\n * - If the element has a requestAnimationFrame dependency, set interactivy status for the ScrollElement Class\n *\n * References:\n *\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API}\n */\n\nimport type { IIOOptions } from '../types';\nimport ScrollElement from './ScrollElement';\n\nexport default class IO {\n    public scrollElements: ScrollElement[];\n    private rootMargin: string;\n    private IORaf: boolean;\n    private observer!: IntersectionObserver;\n\n    constructor({\n        scrollElements,\n        rootMargin = '-1px -1px -1px -1px',\n        IORaf,\n    }: IIOOptions) {\n        // Parameters\n        this.scrollElements = scrollElements;\n        this.rootMargin = rootMargin;\n        this.IORaf = IORaf;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize Intersection Observer.\n     *\n     * @private\n     */\n    private _init() {\n        // Options\n        const observerOptions = {\n            rootMargin: this.rootMargin,\n        };\n\n        // Callback\n        const onIntersect = (entries: IntersectionObserverEntry[]) => {\n            entries.forEach((entry) => {\n                const $targetItem: ScrollElement | undefined =\n                    this.scrollElements.find(\n                        (item) => item.$el === entry.target\n                    );\n\n                if (entry.isIntersecting) {\n                    $targetItem && ($targetItem.isAlreadyIntersected = true);\n                    this._setInview(entry);\n                } else if ($targetItem && $targetItem.isAlreadyIntersected) {\n                    this._setOutOfView(entry);\n                }\n            });\n        };\n\n        // Instance\n        this.observer = new IntersectionObserver(onIntersect, observerOptions);\n\n        // Observe each default elements\n        for (const scrollElement of this.scrollElements) {\n            const $scrollElement = scrollElement.$el;\n            this.observe($scrollElement);\n        }\n    }\n\n    /**\n     * Lifecyle - Destroy Intersection Observer.\n     */\n    public destroy() {\n        this.observer.disconnect();\n    }\n\n    /**\n     * Subscribe element to the Intersection Observer.\n     *\n     * @param {HTMLElement} $scrollElement - DOM Element to observe.\n     */\n    public observe($scrollElement: HTMLElement) {\n        if (!$scrollElement) {\n            return;\n        }\n\n        this.observer.observe($scrollElement);\n    }\n\n    /**\n     * Unsubscribe element to the Intersection Observer.\n     *\n     * @param {HTMLElement} $scrollElement - DOM Element to unobserve.\n     */\n    public unobserve($scrollElement: HTMLElement) {\n        if (!$scrollElement) {\n            return;\n        }\n\n        this.observer.unobserve($scrollElement);\n    }\n\n    /**\n     * Find ScrollElementReference instance and trigger inview callbacks.\n     *\n     * @private\n     *\n     * @param {IntersectionObserverEntry} entry - DOM Element to observe.\n     */\n    private _setInview(entry: IntersectionObserverEntry) {\n        const scrollElement = this.scrollElements.find(\n            (scrollElement) => scrollElement.$el === entry.target\n        );\n\n        this.IORaf && scrollElement?.setInteractivityOn();\n        !this.IORaf && scrollElement?.setInview();\n    }\n\n    /**\n     * Find ScrollElementReference instance and trigger out of view callbacks.\n     *\n     * @private\n     *\n     * @param {IntersectionObserverEntry} entry - DOM Element to observe.\n     */\n    private _setOutOfView(entry: IntersectionObserverEntry) {\n        const scrollElement = this.scrollElements.find(\n            (scrollElement) => scrollElement.$el === entry.target\n        );\n\n        this.IORaf && scrollElement?.setInteractivityOff();\n        !this.IORaf && scrollElement?.setOutOfView();\n\n        // Unobserve if element doesn't have repeat attribute\n        if (!scrollElement?.attributes.scrollRepeat && !this.IORaf) {\n            this.unobserve(entry.target as HTMLElement);\n        }\n    }\n}\n","// https://greensock.com/docs/v3/GSAP/gsap.utils\n\n/**\n * Clamp a value to fit within a specific range (ex: clamp(0, 100, -12) --> 0).\n *\n * @param {number} min   - Minimum value expected.\n * @param {number} max   - Maximum value expected.\n * @param {number} value - Current value.\n *\n * @returns {number} - Clamped value.\n */\nexport function clamp(min: number, max: number, value: number): number {\n    return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Map one range to another (ex: mapRange(-10, 10, 0, 100, 5) --> 75).\n *\n * @param {number} inMin  - Current minimum value.\n * @param {number} inMax  - Current maximum value.\n * @param {number} outMin - Maximum value expected.\n * @param {number} outMax - Maximum value expected.\n * @param {number} value  - Current value.\n *\n * @returns {number} - New value that should be between minimum value expected and maximum value.\n */\nexport function mapRange(\n    inMin: number,\n    inMax: number,\n    outMin: number,\n    outMax: number,\n    value: number\n): number {\n    const inRange = inMax - inMin;\n    const outRange = outMax - outMin;\n    return outMin + (((value - inMin) / inRange) * outRange || 0);\n}\n\n/**\n * Map a number within a range to a progress between 0 to 1 (ex: normalize(100, 200, 150) --> 0.5).\n *\n * @param {number} min   - Current minimum value.\n * @param {number} max   - Current maximum value.\n * @param {number} value - Current value.\n *\n * @returns {number} - New value that should be between 0 and 1.\n */\nexport function normalize(min: number, max: number, value: number): number {\n    return mapRange(min, max, 0, 1, value);\n}\n\n/**\n * Get closest number from an array.\n *\n * @param {number[]} array  - Numbers array.\n * @param {number}   target - Reference value.\n *\n * @returns {number} - Closest number.\n */\nexport function closestNumber(array: number[], target: number): number {\n    return array.reduce((prev, curr) => {\n        return Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev;\n    });\n}\n","/**\n * Scroll Element\n *\n * Give tools to compute element progress in the viewport and triggers callbacks to animate it.\n *\n * Features functions to:\n *\n * - scrollClass - Add a custom class when the element is intersected by the offset\n * - scrollOffset - Determine offsets to intersect the element\n * - scrollPosition - Determine the element positions to consider an element as intersected.\n * - scrollModuleProgress - Send scroll progress to modular module that have a specific method (PROGRESS_MODULAR_METHOD)\n * - scrollCssProgress - Add a specific css variable (PROGRESS_CSS_VAR) that store the scroll progress\n * - scrollEventProgress - Send scroll progress to custom event listeners.\n * - scrollSpeed - Add a scroll multiplicator to create a parallax effect\n * - scrollRepeat - Repeat the option to trigger animation each time the element is intersected\n * - scrollCall - Call a custom event or a modular callback when the element is intersected\n */\n\nimport type {\n    IModular,\n    IScrollElementOptions,\n    IScrollElementAttributes,\n    IScrollElementIntersection,\n    IScrollElementMetrics,\n    IProgressModularModules,\n    IScrollElementCallbacksValues,\n    scrollCallWay,\n    scrollCallFrom,\n    scrollOrientation,\n} from '../types';\nimport { clamp, closestNumber, normalize, mapRange } from '../utils/maths';\n\n/** Constants */\nconst INVIEW_CLASS = 'is-inview';\nconst PROGRESS_CSS_VAR = '--progress';\nconst PROGRESS_MODULAR_METHOD = 'onScrollProgress';\n\nexport default class ScrollElement {\n    public $el: HTMLElement;\n    public id: number;\n    public needRaf: boolean;\n    public attributes: IScrollElementAttributes;\n    public scrollOrientation: scrollOrientation;\n    public isAlreadyIntersected: boolean;\n\n    private intersection: IScrollElementIntersection;\n    private metrics: IScrollElementMetrics;\n    private currentScroll: number;\n    private translateValue: number;\n    private progress: number;\n    private lastProgress: number | null;\n    private modularInstance?: IModular;\n    private progressModularModules: IProgressModularModules[];\n    private isInview: boolean;\n    private isInteractive: boolean;\n    private isInFold: boolean;\n    private isFirstResize: boolean;\n\n    private subscribeElementUpdateFn: (scrollElement: ScrollElement) => void;\n    private unsubscribeElementUpdateFn: (scrollElement: ScrollElement) => void;\n\n    constructor({\n        $el,\n        id,\n        modularInstance,\n        subscribeElementUpdateFn,\n        unsubscribeElementUpdateFn,\n        needRaf,\n        scrollOrientation,\n    }: IScrollElementOptions) {\n        // Scroll DOM element\n        this.$el = $el;\n        // Unique ID\n        this.id = id;\n        // RAF option\n        this.needRaf = needRaf;\n        // Scroll Direction\n        this.scrollOrientation = scrollOrientation;\n        // Modular.js\n        this.modularInstance = modularInstance;\n        // Parent's callbacks\n        this.subscribeElementUpdateFn = subscribeElementUpdateFn;\n        this.unsubscribeElementUpdateFn = unsubscribeElementUpdateFn;\n\n        // Attributes\n        this.attributes = {\n            scrollClass: this.$el.dataset['scrollClass'] ?? INVIEW_CLASS,\n            scrollOffset: this.$el.dataset['scrollOffset'] ?? '0,0',\n            scrollPosition: this.$el.dataset['scrollPosition'] ?? 'start,end',\n            scrollModuleProgress:\n                this.$el.dataset['scrollModuleProgress'] != null,\n            scrollCssProgress: this.$el.dataset['scrollCssProgress'] != null,\n            scrollEventProgress:\n                this.$el.dataset['scrollEventProgress'] ?? null,\n            scrollSpeed:\n                this.$el.dataset['scrollSpeed'] != null\n                    ? parseFloat(this.$el.dataset['scrollSpeed'])\n                    : null,\n            scrollRepeat: this.$el.dataset['scrollRepeat'] != null,\n            scrollCall: this.$el.dataset['scrollCall'] ?? null,\n            scrollCallSelf: this.$el.dataset['scrollCallSelf'] != null,\n            scrollIgnoreFold: this.$el.dataset['scrollIgnoreFold'] != null,\n            scrollEnableTouchSpeed:\n                this.$el.dataset['scrollEnableTouchSpeed'] != null,\n        };\n\n        // Limits\n        this.intersection = {\n            start: 0,\n            end: 0,\n        };\n\n        // Metrics\n        this.metrics = {\n            offsetStart: 0,\n            offsetEnd: 0,\n            bcr: {} as DOMRect,\n        };\n\n        // Scroll Values\n        this.currentScroll =\n            this.scrollOrientation === 'vertical'\n                ? window.scrollY\n                : window.scrollX;\n\n        // Parallax\n        this.translateValue = 0;\n\n        // Progress\n        this.progress = 0;\n        this.lastProgress = null;\n        this.progressModularModules = [];\n\n        // Inview\n        this.isInview = false;\n        this.isInteractive = false;\n        this.isAlreadyIntersected = false;\n        this.isInFold = false;\n        this.isFirstResize = true;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize progress tracking.\n     *\n     * @private\n     */\n    private _init() {\n        if (!this.needRaf) {\n            return;\n        }\n\n        // Prepare modules progress\n        if (this.modularInstance && this.attributes.scrollModuleProgress) {\n            this._getProgressModularModules();\n        }\n\n        // First resize to compute all values\n        this._resize();\n    }\n\n    /**\n     * Callback - Resize callback\n     */\n    public onResize({ currentScroll }: IScrollElementCallbacksValues) {\n        this.currentScroll = currentScroll;\n        this._resize();\n    }\n\n    /**\n     * Callback - RAF callback\n     */\n    public onRender({ currentScroll, smooth }: IScrollElementCallbacksValues) {\n        const wSize =\n            this.scrollOrientation === 'vertical'\n                ? window.innerHeight\n                : window.innerWidth;\n        this.currentScroll = currentScroll;\n        this._computeProgress();\n\n        // Parallax\n        if (\n            this.attributes.scrollSpeed &&\n            !isNaN(this.attributes.scrollSpeed)\n        ) {\n            // if touch detected or smooth disabled\n            if (!this.attributes.scrollEnableTouchSpeed && !smooth) {\n                if (this.translateValue) {\n                    this.$el.style.transform = `translate3d(0, 0, 0)`;\n                }\n                this.translateValue = 0;\n\n                // if mousewheel or smooth enabled\n            } else {\n                // Check fold condition\n                if (this.isInFold) {\n                    const progress = Math.max(0, this.progress);\n                    this.translateValue =\n                        progress * wSize * this.attributes.scrollSpeed * -1;\n                } else {\n                    const progress = mapRange(0, 1, -1, 1, this.progress);\n                    this.translateValue =\n                        progress * wSize * this.attributes.scrollSpeed * -1;\n                }\n\n                this.$el.style.transform =\n                    this.scrollOrientation === 'vertical'\n                        ? `translate3d(0, ${this.translateValue}px, 0)`\n                        : `translate3d(${this.translateValue}px, 0, 0)`;\n            }\n        }\n    }\n\n    /**\n     * Inview callback\n     */\n    public setInview() {\n        if (this.isInview) {\n            return;\n        }\n\n        this.isInview = true;\n        this.$el.classList.add(this.attributes.scrollClass);\n\n        const way: scrollCallWay = 'enter';\n        const from: scrollCallFrom = this._getScrollCallFrom();\n        this.attributes.scrollCall && this._dispatchCall(way, from);\n    }\n\n    /**\n     * Out of view callback\n     */\n    public setOutOfView() {\n        if (!(this.isInview && this.attributes.scrollRepeat)) {\n            return;\n        }\n\n        this.isInview = false;\n        this.$el.classList.remove(this.attributes.scrollClass);\n\n        const way: scrollCallWay = 'leave';\n        const from: scrollCallFrom = this._getScrollCallFrom();\n        this.attributes.scrollCall && this._dispatchCall(way, from);\n    }\n\n    /**\n     * Switch interactivity on to subscribe the instance to the RAF\n     * and start calculations.\n     */\n    public setInteractivityOn() {\n        if (this.isInteractive) {\n            return;\n        }\n\n        this.isInteractive = true;\n        this.subscribeElementUpdateFn(this);\n    }\n\n    /**\n     * Switch interactivity off to unsubscribe the instance to the RAF\n     * and stop calculations.\n     */\n    public setInteractivityOff() {\n        if (!this.isInteractive) {\n            return;\n        }\n\n        this.isInteractive = false;\n        this.unsubscribeElementUpdateFn(this);\n\n        // Force progress to progress limit when the element is out\n        this.lastProgress != null &&\n            this._computeProgress(closestNumber([0, 1], this.lastProgress));\n    }\n\n    /**\n     * Resize method that compute the element's values.\n     *\n     * @private\n     */\n    private _resize() {\n        this.metrics.bcr = this.$el.getBoundingClientRect();\n        this._computeMetrics();\n        this._computeIntersection();\n\n        // First resize logic\n        if (this.isFirstResize) {\n            this.isFirstResize = false;\n            // Dispatch default call if the element is in fold.\n            if (this.isInFold) {\n                this.setInview();\n            }\n        }\n    }\n\n    /**\n     * Compute element's offsets and determine if the element is in fold.\n     *\n     * @private\n     */\n    private _computeMetrics() {\n        const { top, left, height, width } = this.metrics.bcr;\n        const wSize =\n            this.scrollOrientation === 'vertical'\n                ? window.innerHeight\n                : window.innerWidth;\n        const metricsStart = this.scrollOrientation === 'vertical' ? top : left;\n        const metricsSize =\n            this.scrollOrientation === 'vertical' ? height : width;\n\n        this.metrics.offsetStart =\n            this.currentScroll + metricsStart - this.translateValue;\n        this.metrics.offsetEnd = this.metrics.offsetStart + metricsSize;\n\n        if (\n            this.metrics.offsetStart < wSize &&\n            !this.attributes.scrollIgnoreFold\n        ) {\n            this.isInFold = true;\n        } else {\n            this.isInFold = false;\n        }\n    }\n\n    /**\n     * Compute intersection values depending on the context.\n     *\n     * @private\n     */\n    private _computeIntersection() {\n        // Window size\n        const wSize =\n            this.scrollOrientation === 'vertical'\n                ? window.innerHeight\n                : window.innerWidth;\n\n        // Metrics size\n        const metricsSize =\n            this.scrollOrientation === 'vertical'\n                ? this.metrics.bcr.height\n                : this.metrics.bcr.width;\n\n        // Offset\n        const offset = this.attributes.scrollOffset.split(',');\n        const offsetStart = offset[0] != undefined ? offset[0].trim() : '0';\n        const offsetEnd = offset[1] != undefined ? offset[1].trim() : '0';\n\n        // Positions\n        const scrollPosition = this.attributes.scrollPosition.split(',');\n        let scrollPositionStart =\n            scrollPosition[0] != undefined ? scrollPosition[0].trim() : 'start';\n        const scrollPositionEnd =\n            scrollPosition[1] != undefined ? scrollPosition[1].trim() : 'end';\n\n        // Viewport\n        const viewportStart = offsetStart.includes('%')\n            ? wSize * parseInt(offsetStart.replace('%', '').trim()) * 0.01\n            : parseInt(offsetStart);\n        const viewportEnd = offsetEnd.includes('%')\n            ? wSize * parseInt(offsetEnd.replace('%', '').trim()) * 0.01\n            : parseInt(offsetEnd);\n\n        // Fold exception\n        if (this.isInFold) {\n            scrollPositionStart = 'fold';\n        }\n\n        // Define Intersection Start\n        switch (scrollPositionStart) {\n            case 'start':\n                this.intersection.start =\n                    this.metrics.offsetStart - wSize + viewportStart;\n                break;\n\n            case 'middle':\n                this.intersection.start =\n                    this.metrics.offsetStart -\n                    wSize +\n                    viewportStart +\n                    metricsSize * 0.5;\n                break;\n\n            case 'end':\n                this.intersection.start =\n                    this.metrics.offsetStart -\n                    wSize +\n                    viewportStart +\n                    metricsSize;\n                break;\n\n            case 'fold':\n                this.intersection.start = 0;\n                break;\n\n            default:\n                this.intersection.start =\n                    this.metrics.offsetStart - wSize + viewportStart;\n                break;\n        }\n\n        // Define Intersection End\n        switch (scrollPositionEnd) {\n            case 'start':\n                this.intersection.end = this.metrics.offsetStart - viewportEnd;\n                break;\n\n            case 'middle':\n                this.intersection.end =\n                    this.metrics.offsetStart - viewportEnd + metricsSize * 0.5;\n                break;\n\n            case 'end':\n                this.intersection.end =\n                    this.metrics.offsetStart - viewportEnd + metricsSize;\n                break;\n\n            default:\n                this.intersection.end =\n                    this.metrics.offsetStart - viewportEnd + metricsSize;\n                break;\n        }\n\n        // Avoid to have the end < the start intersection >\n        if (this.intersection.end <= this.intersection.start) {\n            switch (scrollPositionEnd) {\n                case 'start':\n                    this.intersection.end = this.intersection.start + 1;\n                    break;\n\n                case 'middle':\n                    this.intersection.end =\n                        this.intersection.start + metricsSize * 0.5;\n                    break;\n\n                case 'end':\n                    this.intersection.end =\n                        this.intersection.start + metricsSize;\n                    break;\n\n                default:\n                    this.intersection.end = this.intersection.start + 1;\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Compute the scroll progress of the element depending\n     * on its intersection values.\n     *\n     * @private\n     *\n     * @param {number} [forcedProgress] - Value to force progress.\n     */\n    private _computeProgress(forcedProgress?: number) {\n        // Progress\n        const progress =\n            forcedProgress ??\n            clamp(\n                0,\n                1,\n                normalize(\n                    this.intersection.start,\n                    this.intersection.end,\n                    this.currentScroll\n                )\n            );\n\n        this.progress = progress;\n\n        if (progress != this.lastProgress) {\n            this.lastProgress = progress;\n\n            // Set the element's progress to the css variable\n            this.attributes.scrollCssProgress && this._setCssProgress(progress);\n\n            // Set the element's progress to the custom event listeners\n            this.attributes.scrollEventProgress &&\n                this._setCustomEventProgress(progress);\n\n            // Set the element's progress to inline modules\n            if (this.attributes.scrollModuleProgress) {\n                for (const modularModules of this.progressModularModules) {\n                    this.modularInstance &&\n                        this.modularInstance.call(\n                            PROGRESS_MODULAR_METHOD,\n                            progress,\n                            modularModules.moduleName,\n                            modularModules.moduleId\n                        );\n                }\n            }\n\n            // Logic to trigger the inview/out of view callbacks\n            progress > 0 && progress < 1 && this.setInview();\n            progress === 0 && this.setOutOfView();\n            progress === 1 && this.setOutOfView();\n        }\n    }\n\n    /**\n     * Set the element's progress to a specific css variable.\n     *\n     * @private\n     *\n     * @param {number} [currentProgress] - Progress value.\n     */\n    _setCssProgress(currentProgress = 0) {\n        this.$el.style.setProperty(\n            PROGRESS_CSS_VAR,\n            currentProgress.toString()\n        );\n    }\n\n    /**\n     * Set the element's progress to the custom event listeners.\n     *\n     * @private\n     *\n     * @param {number} [currentProgress] - Progress value.\n     */\n    _setCustomEventProgress(currentProgress = 0) {\n        const customEventName = this.attributes.scrollEventProgress;\n\n        if (!customEventName) return;\n\n        const customEvent = new CustomEvent(customEventName, {\n            detail: {\n                target: this.$el,\n                progress: currentProgress,\n            },\n        });\n        window.dispatchEvent(customEvent);\n    }\n\n    /**\n     * Get modular modules that can listen the element's progress.\n     *\n     * @private\n     */\n    _getProgressModularModules() {\n        if (!this.modularInstance) {\n            return;\n        }\n\n        const modulesIdNames = Object.keys(this.$el.dataset).filter((key) =>\n            key.includes('module')\n        );\n        const modules: any[] = Object.entries(this.modularInstance.modules);\n\n        if (!modulesIdNames.length) {\n            return;\n        }\n\n        for (const modulesIdName of modulesIdNames) {\n            const moduleId = this.$el.dataset[modulesIdName];\n\n            if (!moduleId) {\n                return;\n            }\n\n            for (const module of modules) {\n                const [moduleName, moduleObj] = module;\n\n                if (moduleId in moduleObj) {\n                    this.progressModularModules.push({\n                        moduleName,\n                        moduleId,\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * Function to get scroll call from.\n     *\n     * @private\n     */\n    _getScrollCallFrom(): scrollCallFrom {\n        const closestIntersectionValue = closestNumber(\n            [this.intersection.start, this.intersection.end],\n            this.currentScroll\n        );\n        return this.intersection.start === closestIntersectionValue\n            ? 'start'\n            : 'end';\n    }\n\n    /**\n     * Function to dispatch a custom event or call a modular callback.\n     *\n     * @private\n     *\n     * @param {scrollCallWay} way - Enter or leave.\n     * @param {scrollCallFrom} from - Start or end.\n     */\n    _dispatchCall(way: scrollCallWay, from: scrollCallFrom) {\n        const callParameters = this.attributes.scrollCall?.split(',');\n        const callSelf = this.attributes?.scrollCallSelf;\n\n        if (callParameters && callParameters.length > 1) {\n            // Using Modular.js (https://github.com/modularorg/modularjs)\n            const [func, moduleName, moduleId] = callParameters;\n            let targetModuleId;\n\n            // If the module is set on the scroll element\n            if (callSelf) {\n                targetModuleId = this.$el.dataset[`module${moduleName.trim()}`];\n            } else {\n                targetModuleId = moduleId;\n            }\n\n            this.modularInstance &&\n                this.modularInstance.call(\n                    func.trim(),\n                    {\n                        target: this.$el,\n                        way,\n                        from,\n                    },\n                    moduleName.trim(),\n                    targetModuleId?.trim()\n                );\n        } else if (callParameters) {\n            // Using CustomEvent API (https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent)\n            const [customEventName] = callParameters;\n            const customEvent = new CustomEvent(customEventName, {\n                detail: {\n                    target: this.$el,\n                    way,\n                    from,\n                },\n            });\n            window.dispatchEvent(customEvent);\n        }\n    }\n}\n","/**\n * Integrates Lenis with Locomotive's built-in animation system\n */\n\nimport type {\n    CoreOptions,\n    IModular,\n    IScrollElementCallbacksValues,\n    scrollOrientation,\n} from '../types';\nimport IO from './IO';\nimport ScrollElement from './ScrollElement';\n\n/** Defined attributes that need a requestAnimationFrame */\nconst ATTRIBUTES_THAT_NEED_RAF = [\n    'scrollOffset',\n    'scrollPosition',\n    'scrollModuleProgress',\n    'scrollCssProgress',\n    'scrollEventProgress',\n    'scrollSpeed',\n];\n\n/** Default root margins */\nconst TRIGGER_ROOT_MARGIN = '-1px -1px -1px -1px';\nconst RAF_ROOT_MARGIN = '100% 100% 100% 100%'; // Add 100vh top/bottom && 100vw left/right to use a biggest value with data-scroll-speed\n\nexport default class Core {\n    private $scrollContainer!: HTMLElement;\n    private modularInstance?: IModular;\n    private triggerRootMargin!: string;\n    private rafRootMargin!: string;\n    private scrollElements!: ScrollElement[];\n    private triggeredScrollElements!: ScrollElement[];\n    private RAFScrollElements!: ScrollElement[];\n    private scrollElementsToUpdate!: ScrollElement[];\n    private IOTriggerInstance!: IO;\n    private IORafInstance!: IO;\n    private scrollOrientation!: scrollOrientation;\n\n    constructor({\n        $el,\n        modularInstance,\n        triggerRootMargin,\n        rafRootMargin,\n        scrollOrientation,\n    }: CoreOptions) {\n        if (!$el) {\n            console.error('Please provide a DOM Element as scrollContainer');\n            return;\n        }\n\n        // Scroll container\n        this.$scrollContainer = $el;\n\n        // Modular.js\n        this.modularInstance = modularInstance;\n\n        // Scroll Direction\n        this.scrollOrientation = scrollOrientation;\n\n        // IO Margins\n        this.triggerRootMargin = triggerRootMargin ?? TRIGGER_ROOT_MARGIN;\n        this.rafRootMargin = rafRootMargin ?? RAF_ROOT_MARGIN;\n\n        // ScrollElements arrays\n        this.scrollElements = [];\n        this.triggeredScrollElements = [];\n        this.RAFScrollElements = [];\n        this.scrollElementsToUpdate = [];\n\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize the core.\n     *\n     * @private\n     */\n    private _init() {\n        const $scrollElements =\n            this.$scrollContainer.querySelectorAll('[data-scroll]');\n\n        const $scrollElementsArr = Array.from($scrollElements) as HTMLElement[]\n        this._subscribeScrollElements($scrollElementsArr);\n\n        // Trigger IO\n        this.IOTriggerInstance = new IO({\n            scrollElements: [...this.triggeredScrollElements],\n            rootMargin: this.triggerRootMargin,\n            IORaf: false,\n        });\n\n        // Raf IO\n        this.IORafInstance = new IO({\n            scrollElements: [...this.RAFScrollElements],\n            rootMargin: this.rafRootMargin,\n            IORaf: true,\n        });\n    }\n\n    /**\n     * Lifecyle - Destroy core.\n     */\n    public destroy() {\n        this.IOTriggerInstance.destroy();\n        this.IORafInstance.destroy();\n        this._unsubscribeAllScrollElements();\n    }\n\n    /**\n     * Callback - Resize callback.\n     */\n    onResize({ currentScroll }: IScrollElementCallbacksValues) {\n        for (const scrollElement of this.RAFScrollElements) {\n            scrollElement.onResize({\n                currentScroll,\n            } as IScrollElementCallbacksValues);\n        }\n    }\n\n    /**\n     * Callback - RAF callback.\n     */\n    onRender({ currentScroll, smooth }: IScrollElementCallbacksValues) {\n        for (const scrollElement of this.scrollElementsToUpdate) {\n            scrollElement.onRender({\n                currentScroll,\n                smooth,\n            } as IScrollElementCallbacksValues);\n        }\n    }\n\n    /**\n     * Remove items from lists of scroll elements and compute all new values.\n     *\n     * @param {HTMLElement} $oldContainer - HTMLElement that contains data-scroll elements to unsubscribe\n     */\n    removeScrollElements($oldContainer: HTMLElement) {\n        const $scrollElementsToRemove =\n            $oldContainer.querySelectorAll('[data-scroll]');\n\n        if (!$scrollElementsToRemove.length) return;\n\n        // 1. Remove from IO\n        for (let index = 0; index < this.triggeredScrollElements.length; index++) {\n            const scrollElement = this.triggeredScrollElements[index];\n            const $scrollElementsToRemoveArr = Array.from($scrollElementsToRemove) as HTMLElement []\n            if ($scrollElementsToRemoveArr.indexOf(scrollElement.$el) > -1) {\n                this.IOTriggerInstance.unobserve(scrollElement.$el);\n                this.triggeredScrollElements.splice(index, 1);\n            }\n        }\n\n        for (let index = 0; index < this.RAFScrollElements.length; index++) {\n            const scrollElement = this.RAFScrollElements[index];\n            const $scrollElementsToRemoveArr = Array.from($scrollElementsToRemove) as HTMLElement []\n            if ($scrollElementsToRemoveArr.indexOf(scrollElement.$el) > -1) {\n                this.IORafInstance.unobserve(scrollElement.$el);\n                this.RAFScrollElements.splice(index, 1);\n            }\n        }\n\n        // 2. Remove from scrollElementsToUpdate[] and scrollElements[]\n        $scrollElementsToRemove.forEach(($scrollElement) => {\n            const targetScrollElementToUpdate =\n                this.scrollElementsToUpdate.find(\n                    (scrollElement) => scrollElement.$el === $scrollElement\n                );\n            const targetScrollElement = this.scrollElements.find(\n                (scrollElement) => scrollElement.$el === $scrollElement\n            );\n\n            if (targetScrollElementToUpdate) {\n                this._unsubscribeElementUpdate(targetScrollElementToUpdate);\n            }\n            if (targetScrollElement) {\n                this.scrollElements = this.scrollElements.filter(\n                    (scrollElementItem) =>\n                        scrollElementItem.id != targetScrollElement.id\n                );\n            }\n        });\n    }\n\n    /**\n     * Add items to lists of scroll elements and compute all new values.\n     *\n     * @param {HTMLElement} $newContainer - HTMLElement that contains data-scroll elements to subscribe\n     */\n    addScrollElements($newContainer: HTMLElement) {\n        // 3. Rebuild ScrollElements\n        const $scrollElements = $newContainer.querySelectorAll('[data-scroll]');\n\n        // 4. Get max scrollElement.id\n        const ids: number[] = [];\n        this.scrollElements.forEach((scrollElement) => {\n            ids.push(scrollElement.id);\n        });\n        const maxID = Math.max(...ids, 0);\n        const fromIndex = maxID + 1;\n        const $scrollElementsArr = Array.from($scrollElements) as HTMLElement[]\n        this._subscribeScrollElements(\n            $scrollElementsArr,\n            fromIndex,\n            true\n        );\n    }\n\n    /**\n     * Create a ScrollElement instance for each elements with\n     * `data-scroll` attribute.\n     *\n     * @private\n     *\n     * @param {HTMLElement[]} $scrollElements - List of elements that need\n     *     to be regarded.\n     */\n    _subscribeScrollElements(\n        $scrollElements: HTMLElement[],\n        fromIndex = 0,\n        toObserve = false\n    ) {\n        // For each scroll element create a ScrollElement instance\n        for (let index = 0; index < $scrollElements.length; index++) {\n            const $scrollElement = $scrollElements[index];\n            const needRaf = this._checkRafNeeded($scrollElement);\n\n            const scrollElementInstance = new ScrollElement({\n                $el: $scrollElement,\n                id: fromIndex + index,\n                scrollOrientation: this.scrollOrientation,\n                modularInstance: this.modularInstance,\n                subscribeElementUpdateFn:\n                    this._subscribeElementUpdate.bind(this),\n                unsubscribeElementUpdateFn:\n                    this._unsubscribeElementUpdate.bind(this),\n                needRaf,\n            });\n\n            // Push to common array\n            this.scrollElements.push(scrollElementInstance);\n\n            // Push to specific array\n            if (needRaf) {\n                this.RAFScrollElements.push(scrollElementInstance);\n\n                // Dynamic observe item\n                if (toObserve) {\n                    this.IORafInstance.scrollElements.push(\n                        scrollElementInstance\n                    );\n                    this.IORafInstance.observe(scrollElementInstance.$el);\n                }\n            } else {\n                this.triggeredScrollElements.push(scrollElementInstance);\n\n                // Dynamic observe item\n                if (toObserve) {\n                    this.IOTriggerInstance.scrollElements.push(\n                        scrollElementInstance\n                    );\n                    this.IOTriggerInstance.observe(scrollElementInstance.$el);\n                }\n            }\n        }\n    }\n\n    /**\n     * Clear all ScrollElement arrays.\n     *\n     * @private\n     */\n    _unsubscribeAllScrollElements() {\n        this.scrollElements = [];\n        this.RAFScrollElements = [];\n        this.triggeredScrollElements = [];\n        this.scrollElementsToUpdate = [];\n    }\n\n    /**\n     * Subscribe ScrollElement instance that needs to be updated.\n     *\n     * @private\n     *\n     * @param {ScrollElement} scrollElement - ScrollElement instance inview\n     *     that needs to be updated.\n     */\n    _subscribeElementUpdate(scrollElement: ScrollElement) {\n        this.scrollElementsToUpdate.push(scrollElement);\n    }\n\n    /**\n     * Unscribe ScrollElement instance that doesn't need to be updated.\n     *\n     * @private\n     *\n     * @param {ScrollElement} scrollElement - The updated ScrollElement instance\n     *     out of view now.\n     */\n    _unsubscribeElementUpdate(scrollElement: ScrollElement) {\n        this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(\n            (scrollElementToUpdate) =>\n                scrollElementToUpdate.id != scrollElement.id\n        );\n    }\n\n    /**\n     * Check if a DOM Element need a requestAnimationFrame to be used.\n     *\n     * @private\n     *\n     * @param {HTMLElement} $scrollElement - The element that needs to be checked.\n     *\n     * @returns {boolean}\n     */\n    _checkRafNeeded($scrollElement: HTMLElement) {\n        let attributesThatNeedRaf = [...ATTRIBUTES_THAT_NEED_RAF];\n\n        // Remove utils\n        const removeAttribute = (attributeToRemove: string) => {\n            attributesThatNeedRaf = attributesThatNeedRaf.filter(\n                (attribute) => attribute != attributeToRemove\n            );\n        };\n\n        // 1. Check scroll offset values\n        if ($scrollElement.dataset.scrollOffset) {\n            const value = $scrollElement.dataset.scrollOffset\n                .split(',')\n                .map((test) => test.replace('%', '').trim())\n                .join(',');\n            if (value != '0,0') {\n                return true;\n            } else {\n                removeAttribute('scrollOffset');\n            }\n        } else {\n            removeAttribute('scrollOffset');\n        }\n\n        // 2. Check scroll position values\n        if ($scrollElement.dataset.scrollPosition) {\n            const value = $scrollElement.dataset.scrollPosition.trim();\n            if (value != 'top,bottom') {\n                return true;\n            } else {\n                removeAttribute('scrollPosition');\n            }\n        } else {\n            removeAttribute('scrollPosition');\n        }\n\n        // 3. Check scroll speed values\n        if (\n            $scrollElement.dataset.scrollSpeed &&\n            !isNaN(parseFloat($scrollElement.dataset.scrollSpeed))\n        ) {\n            return true;\n        } else {\n            removeAttribute('scrollSpeed');\n        }\n\n        // 4. Check others attributes\n        for (const attribute of attributesThatNeedRaf) {\n            if (attribute in $scrollElement.dataset) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n","/**\n * Resize Observer\n *\n * The Resize Observer API provides a performant mechanism by which code can monitor an element for changes to its size,\n * with notifications being delivered to the observer each time the size changes.\n *\n * Features functions to:\n *\n * - Trigger the resize callback if the specified element's size change.\n *\n * References:\n *\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Resize_Observer_API}\n */\n\nimport type { IROOptions } from '../types';\n\nexport default class RO {\n    private $resizeElements: HTMLElement[];\n    private isFirstObserve: boolean;\n    private observer!: ResizeObserver;\n    private resizeCallback: () => void;\n\n    constructor({ resizeElements, resizeCallback = () => {} }: IROOptions) {\n        // Parameters\n        this.$resizeElements = resizeElements;\n        this.resizeCallback = resizeCallback;\n\n        // Flags\n        this.isFirstObserve = true;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize Resize Observer.\n     *\n     * @private\n     */\n    private _init() {\n        // Callback\n        const onResize = (entries: ResizeObserverEntry[]) => {\n            !this.isFirstObserve && this.resizeCallback?.();\n            this.isFirstObserve = false;\n        };\n\n        // Instance\n        this.observer = new ResizeObserver(onResize);\n\n        // Observe each default elements\n        for (const $resizeElement of this.$resizeElements) {\n            this.observer.observe($resizeElement);\n        }\n    }\n\n    /**\n     * Lifecyle - Destroy Resize Observer.\n     */\n    public destroy() {\n        this.observer.disconnect();\n    }\n}\n","//@ts-ignore\nimport Lenis from 'lenis';\nimport Core from './core/Core';\nimport RO from './core/RO';\nimport type {\n    ILenisScrollToOptions,\n    ILenisScrollValues,\n    ILocomotiveScrollOptions,\n    IModular,\n    lenisTargetScrollTo,\n} from './types';\nimport type { LenisOptions } from 'lenis';\n\n/**\n * Locomotive Scroll\n *\n * Detection of elements in viewport & smooth scrolling with parallax.\n *\n * Inspired by\n * {@link https://github.com/locomotivemtl/locomotive-scroll locomotive-scroll.js}\n * and built around\n * {@link https://github.com/darkroomengineering/lenis lenis.js}.\n */\n\nexport default class LocomotiveScroll {\n    public rafPlaying: boolean;\n    public lenisInstance: any;\n\n    private coreInstance: any;\n\n    private lenisOptions?: LenisOptions;\n    private modularInstance?: IModular;\n    private triggerRootMargin?: string;\n    private rafRootMargin?: string;\n    private rafInstance?: any;\n    private autoResize?: boolean;\n    private autoStart?: boolean;\n    private ROInstance?: RO;\n    private scrollCallback?(scrollValues: ILenisScrollValues): void;\n    private initCustomTicker?: (render: () => void) => void;\n    private destroyCustomTicker?: (render: () => void) => void;\n    private _onRenderBind: () => void;\n    private _onResizeBind: () => void;\n    private _onScrollToBind: (event: MouseEvent) => void;\n\n    constructor({\n        lenisOptions = {},\n        modularInstance,\n        triggerRootMargin,\n        rafRootMargin,\n        autoResize = true,\n        autoStart = true,\n        scrollCallback = () => {},\n        initCustomTicker,\n        destroyCustomTicker,\n    }: ILocomotiveScrollOptions = {}) {\n\n        for (const [key] of Object.entries(lenisOptions)) {\n            if ([\"wrapper\", \"content\", \"infinite\"].includes(key)) {\n                console.warn(`Warning: Key \"${key}\" is not possible to edit in Locomotive Scroll.`);\n            }\n        }\n\n        // Get arguments\n        Object.assign(this, {\n            lenisOptions,\n            modularInstance,\n            triggerRootMargin,\n            rafRootMargin,\n            autoResize,\n            autoStart,\n            scrollCallback,\n            initCustomTicker,\n            destroyCustomTicker,\n        });\n\n\n        // Binding\n        this._onRenderBind = this._onRender.bind(this);\n        this._onScrollToBind = this._onScrollTo.bind(this);\n        this._onResizeBind = this._onResize.bind(this);\n\n        // Data\n        this.rafPlaying = false;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize instance.\n     *\n     * @private\n     */\n    private _init(): void {\n        // Create Lenis instance\n        this.lenisInstance = new Lenis({\n            ...this.lenisOptions,\n            wrapper: window,\n            content: document.documentElement,\n            infinite: false\n        });\n        this.lenisInstance?.on('scroll', this.scrollCallback);\n\n        // Add scroll direction attribute on body\n        document.documentElement.setAttribute(\n            'data-scroll-orientation',\n            this.lenisInstance.options.orientation\n        );\n\n        requestAnimationFrame(() => {\n            // Create Core Instance\n            this.coreInstance = new Core({\n                $el: this.lenisInstance.rootElement,\n                modularInstance: this.modularInstance,\n                triggerRootMargin: this.triggerRootMargin,\n                rafRootMargin: this.rafRootMargin,\n                scrollOrientation: this.lenisInstance.options.orientation,\n            });\n\n            // Bind Events\n            this._bindEvents();\n\n            // RAF warning\n            if (this.initCustomTicker && !this.destroyCustomTicker) {\n                console.warn(\n                    'initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.'\n                );\n            } else if (!this.initCustomTicker && this.destroyCustomTicker) {\n                console.warn(\n                    'destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble.'\n                );\n            }\n\n            // Start RAF\n            this.autoStart && this.start();\n        });\n    }\n\n    /**\n     * Lifecyle - Destroy instance.\n     */\n    public destroy(): void {\n        // Stop raf\n        this.stop();\n        // Unbind Events\n        this._unbindEvents();\n        // Destroy Lenis\n        this.lenisInstance.destroy();\n        // Destroy Core\n        this.coreInstance?.destroy();\n\n        // Ensure a delay before destroying to handle cases of instant destruction\n        requestAnimationFrame(() => {\n            this.coreInstance?.destroy();\n        });\n    }\n\n    /**\n     * Events - Subscribe events to listen.\n     */\n    private _bindEvents() {\n        this._bindScrollToEvents();\n\n        if (this.autoResize) {\n            if ('ResizeObserver' in window) {\n                this.ROInstance = new RO({\n                    resizeElements: [document.body],\n                    resizeCallback: this._onResizeBind,\n                });\n            } else {\n                (window as any).addEventListener('resize', this._onResizeBind);\n            }\n        }\n    }\n\n    /**\n     * Events - Unsubscribe listened events.\n     */\n    private _unbindEvents() {\n        this._unbindScrollToEvents();\n\n        if (this.autoResize) {\n            if ('ResizeObserver' in window) {\n                this.ROInstance && this.ROInstance.destroy();\n            } else {\n                (window as any).removeEventListener(\n                    'resize',\n                    this._onResizeBind\n                );\n            }\n        }\n    }\n\n    /**\n     * Events - Subscribe scrollTo events to listen.\n     */\n    private _bindScrollToEvents($container?: HTMLElement) {\n        const $rootContainer = $container\n            ? $container\n            : this.lenisInstance.rootElement;\n        const $scrollToElements =\n            $rootContainer?.querySelectorAll('[data-scroll-to]');\n\n        $scrollToElements?.length &&\n            $scrollToElements.forEach(($el: HTMLElement): void => {\n                $el.addEventListener('click', this._onScrollToBind, false);\n            });\n    }\n\n    /**\n     * Events - Unsubscribe scrollTo listened events.\n     */\n    private _unbindScrollToEvents($container?: HTMLElement) {\n        const $rootContainer = $container\n            ? $container\n            : this.lenisInstance.rootElement;\n        const $scrollToElements =\n            $rootContainer?.querySelectorAll('[data-scroll-to]');\n        $scrollToElements?.length &&\n            $scrollToElements.forEach(($el: HTMLElement) => {\n                $el.removeEventListener('click', this._onScrollToBind, false);\n            });\n    }\n\n    /**\n     * Callback - Resize callback.\n     */\n    private _onResize() {\n        // Waiting the next frame to get the new current scroll value return by Lenis\n        requestAnimationFrame(() => {\n            this.coreInstance?.onResize({\n                currentScroll: this.lenisInstance.scroll,\n            });\n        });\n    }\n\n    /**\n     * Callback - Render callback.\n     */\n    private _onRender() {\n        this.lenisInstance?.raf(Date.now());\n\n        this.coreInstance?.onRender({\n            currentScroll: this.lenisInstance.scroll,\n            smooth: this.lenisInstance.options.smoothWheel,\n        });\n    }\n\n    /**\n     * Callback - Scroll To callback.\n     */\n    private _onScrollTo(event: MouseEvent) {\n        event.preventDefault();\n        const $target = (event.currentTarget as HTMLElement) ?? null;\n        if (!$target) return;\n        const target =\n            $target.getAttribute('data-scroll-to-href') ||\n            $target.getAttribute('href');\n        const offset = $target.getAttribute('data-scroll-to-offset') || 0;\n        const duration =\n            $target.getAttribute('data-scroll-to-duration') ||\n            this.lenisInstance.options.duration\n        target &&\n            this.scrollTo(target, {\n                offset: typeof offset === 'string' ? parseInt(offset) : offset,\n                duration:\n                    typeof duration === 'string'\n                        ? parseInt(duration)\n                        : duration,\n            });\n    }\n\n    /**\n     * Start RequestAnimationFrame that active Lenis smooth and scroll progress.\n     */\n    public start(): void {\n        if (this.rafPlaying) {\n            return;\n        }\n\n        // Call lenis start method\n        this.lenisInstance?.start();\n\n        this.rafPlaying = true;\n        this.initCustomTicker\n            ? this.initCustomTicker(this._onRenderBind)\n            : this._raf();\n    }\n\n    /**\n     * Stop RequestAnimationFrame that active Lenis smooth and scroll progress.\n     */\n    public stop(): void {\n        if (!this.rafPlaying) {\n            return;\n        }\n\n        // Call lenis stop method\n        this.lenisInstance?.stop();\n\n        this.rafPlaying = false;\n        this.destroyCustomTicker\n            ? this.destroyCustomTicker(this._onRenderBind)\n            : this.rafInstance && cancelAnimationFrame(this.rafInstance);\n    }\n\n    /**\n     * Remove old scroll elements items and rebuild ScrollElements instances.\n     */\n    public removeScrollElements($oldContainer: HTMLElement): void {\n        if (!$oldContainer) {\n            console.error('Please provide a DOM Element as $oldContainer');\n            return;\n        }\n\n        this._unbindScrollToEvents($oldContainer);\n        this.coreInstance?.removeScrollElements($oldContainer);\n    }\n\n    /**\n     * Add new scroll elements items and rebuild ScrollElements instances.\n     */\n    public addScrollElements($newContainer: HTMLElement): void {\n        if (!$newContainer) {\n            console.error('Please provide a DOM Element as $newContainer');\n            return;\n        }\n\n        this.coreInstance?.addScrollElements($newContainer);\n        requestAnimationFrame(() => {\n            this._bindScrollToEvents($newContainer);\n        });\n    }\n\n    /**\n     * Trigger resize callback.\n     */\n    public resize(): void {\n        this._onResizeBind();\n    }\n\n    /**\n     * Trigger scroll to callback.\n     */\n    public scrollTo(\n        target: lenisTargetScrollTo,\n        options?: ILenisScrollToOptions\n    ): void {\n        this.lenisInstance?.scrollTo(target, {\n            offset: options?.offset,\n            lerp: options?.lerp,\n            duration: options?.duration,\n            immediate: options?.immediate,\n            lock: options?.lock,\n            force: options?.force,\n            easing: options?.easing,\n            onComplete: options?.onComplete,\n        });\n    }\n\n    /**\n     * RequestAnimationFrame that active Lenis smooth and scroll progress.\n     *\n     * @private\n     *\n     */\n    private _raf() {\n        this._onRenderBind();\n        this.rafInstance = requestAnimationFrame(() => this._raf());\n    }\n}\n\nexport * from './types';\n"],"names":["clamp","t","i","e","Math","max","min","Animate","constructor","isRunning","value","from","to","duration","currentTime","advance","this","easing","s","lerp","exp","round","stop","onUpdate","call","fromTo","_ref","o","onStart","n","l","Dimensions","wrapper","content","autoResize","debounce","arguments","length","undefined","width","height","scrollWidth","scrollHeight","resize","onWrapperResize","onContentResize","window","innerWidth","innerHeight","HTMLElement","clientWidth","clientHeight","debouncedResize","clearTimeout","setTimeout","apply","addEventListener","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","destroy","disconnect","removeEventListener","limit","x","y","Emitter","events","emit","_len","Array","_key","on","push","filter","off","VirtualScroll","_ref2","wheelMultiplier","touchMultiplier","lastDelta","windowWidth","windowHeight","onTouchStart","clientX","clientY","targetTouches","touchStart","emitter","deltaX","deltaY","event","onTouchMove","r","h","onTouchEnd","onWheel","deltaMode","onWindowResize","element","passive","Lenis","document","documentElement","wheelEventsTarget","eventsTarget","smoothWheel","syncTouch","syncTouchLerp","touchInertiaMultiplier","a","pow","c","infinite","d","orientation","u","gestureOrientation","p","m","v","g","prevent","w","virtualScroll","S","__experimental__naiveDimensions","f","__isScrolling","__isStopped","__isLocked","userData","lastVelocity","velocity","direction","onPointerDown","button","reset","onVirtualScroll","options","ctrlKey","type","includes","isTouching","isStopped","isLocked","composedPath","slice","indexOf","rootElement","find","Element","hasAttribute","classList","contains","preventDefault","isScrolling","animate","abs","scrollTo","targetScroll","Object","assign","programmatic","onNativeScroll","__resetVelocityTimeout","__preventNextNativeScrollEvent","animatedScroll","actualScroll","sign","lenisVersion","body","dimensions","updateClassName","time","cleanUpClassName","setScroll","isHorizontal","scrollLeft","scrollTop","start","raf","offset","immediate","lock","onComplete","force","querySelector","nodeType","getBoundingClientRect","left","top","scroll","preventNextNativeScrollEvent","requestAnimationFrame","progress","isSmooth","className","trim","replace","scrollElements","rootMargin","IORaf","observer","_init","IntersectionObserver","forEach","$el","target","isIntersecting","isAlreadyIntersected","_setInview","_setOutOfView","unobserve","setInteractivityOn","setInview","setInteractivityOff","setOutOfView","attributes","scrollRepeat","reduce","id","modularInstance","subscribeElementUpdateFn","unsubscribeElementUpdateFn","needRaf","scrollOrientation","intersection","metrics","currentScroll","translateValue","lastProgress","progressModularModules","isInview","isInteractive","isInFold","isFirstResize","scrollClass","dataset","scrollOffset","scrollPosition","scrollModuleProgress","scrollCssProgress","scrollEventProgress","scrollSpeed","parseFloat","scrollCall","scrollCallSelf","scrollIgnoreFold","scrollEnableTouchSpeed","end","offsetStart","offsetEnd","bcr","scrollY","scrollX","_getProgressModularModules","_resize","onResize","_ref3","onRender","_ref4","smooth","_computeProgress","isNaN","style","transform","add","_getScrollCallFrom","_dispatchCall","remove","_computeMetrics","_computeIntersection","split","parseInt","_setCssProgress","_setCustomEventProgress","moduleName","moduleId","setProperty","toString","CustomEvent","detail","dispatchEvent","keys","entries","modules","way","_ref5","triggerRootMargin","rafRootMargin","$scrollContainer","triggeredScrollElements","RAFScrollElements","scrollElementsToUpdate","IOTriggerInstance","IORafInstance","console","error","querySelectorAll","_subscribeScrollElements","_unsubscribeAllScrollElements","_ref6","_ref7","removeScrollElements","splice","_unsubscribeElementUpdate","addScrollElements","_checkRafNeeded","_subscribeElementUpdate","bind","map","join","_ref8","resizeElements","resizeCallback","$resizeElements","isFirstObserve","lenisOptions","autoStart","scrollCallback","initCustomTicker","destroyCustomTicker","rafPlaying","lenisInstance","coreInstance","rafInstance","ROInstance","_onRenderBind","_onResizeBind","_onScrollToBind","warn","_onRender","_onScrollTo","_onResize","setAttribute","_bindEvents","_unbindEvents","_bindScrollToEvents","_unbindScrollToEvents","Date","now","currentTarget","getAttribute","_raf","cancelAnimationFrame"],"sourceRoot":""}